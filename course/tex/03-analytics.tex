\section{Аналитический раздел}

Компилятор~---~это программа, которая считывает текст программы, написанной на одном языке~---~исходном, и транслирует (переводит) его в эквивалентный текст на другом языке~---~целевом. Одна из важных ролей компилятора состоит в сообщении об ошибках в исходной программе, обнаруженных в процессе трансляции~\cite{aho2003}.

\subsection{Структура компилятора}

Конструктивно компилятор состоит из~\cite{vladimirtov2004struct,grune2012modern}:
\begin{itemize}
    \item фронтенда (compiler frontend), который занимается построением промежуточного представления из исходного кода и состоит из:
    \begin{itemize}
        \item препроцессора; 
        \item лексического, синтаксического и семантического анализаторов;
        \item генератора промежуточного представления;
    \end{itemize}
    \item мидленд (middle-end), включащий в себя различные оптимизации;
    \item бэкенда (compiler backend), который занимается кодогенерацией.
\end{itemize}

На рисунке~\ref{img:1-1.pdf} представлена схема концептуальной структуры компилятора.
\img{1\textwidth}{1-1.pdf}{Концептуальная структура компилятора}

Рассмотрим работу компилятора по фазам~\cite{serebrykov2001}. Обобщенная структура компилятора и основные фазы компиляции показаны на рисунке~\ref{img:2.png}.

\img{0.8\textwidth}{2.png}{Обобщенная структура и фазы компиляции}

\subsubsection*{Препроцессор}

Иногда сборка поручается программе, который выполняет предварительную обработку перед фазой фронтенда компилятора. 

Препроцессор может~\cite{aho2003,vladimirtov2004struct}:
\begin{enumerate}
    \item раскрывать макросы в инструкции исходного языка;
    \item обрабатывать включение файлов;
    \item обрабатывать языковые расширения.
\end{enumerate}

\subsection{Лексический анализ}

На фазе лексического анализа входная программа, представляющая собой поток литер, разбивается на лексемы~---~слова в соответствии с определениями языка. Основными формализмами, лежащими в основе реализации лексических анализаторов, являются конечные автоматы и регулярные выражения~\cite{serebrykov2001}.

Лексический анализатор может работать в двух основных режимах~\cite{serebrykov2001}:
\begin{enumerate}
    \item как подпрограмма, вызываемая синтаксическим анализатором для получения очередной лексемы;
    \item как полный проход, результатом которого является файл лексем.
\end{enumerate}

В процессе выделения лексем лексический анализатор может~\cite{serebrykov2001}:
\begin{itemize}
    \item cамостоятельно строить таблицы объектов (идентификаторов, строк, чисел и т.д.);
    \item выдавать значения для каждой лексемы при обращении к ней, в этом случае таблицы объектов строятся на последующих фазах (например, при синтаксическом анализе).
\end{itemize}

На этапе лексического анализа обнаруживаются простейшие ошибки~\cite{serebrykov2001}:
\begin{itemize}
    \item недопустимые символы;
    \item неправильная запись чисел;
    \item ошибки в идентификаторах.
\end{itemize}

На рисунке~\ref{img:1-2.pdf} представлен лексический анализатор.

\img{1\textwidth}{1-2.pdf}{Лексический анализатор}

\subsection{Синтаксический анализатор}

Вторая фаза компилятора - синтаксический анализ или разбор (parsing)~\cite{aho2003}.

Основная задача синтаксического анализа~---~разбор структуры программы. Как правило, под структурой понимается дерево, соответствующее разбору в контекстно-свободной грамматике языка~\cite{serebrykov2001}.

Результатом синтаксического анализа является синтаксическое дерево со ссылками на таблицы объектов. В процессе синтаксического анализа также обнаруживаются ошибки, связанные со структурой программы~\cite{serebrykov2001}.

\img{1\textwidth}{1-3.pdf}{Синтаксический анализатор}

\subsection{Семантический анализатор}

Семантический анализатор использует синтаксическое дерево и информацию из таблицы символов для проверки исходной программы на семантическую согласованность с определением языка. Он также собирает информацию о типах и сохраняет ее в синтаксическом дереве или в таблице символов для последующего использования в процессе генерации промежуточного кода~\cite{aho2003}.

Важной частью семантического анализа является проверка типов, когда компилятор проверяет, имеет ли каждый оператор операнды соответствующего типа. Например, многие определения языков программирования требуют, чтобы индекс массива был целым числом; компилятор должен сообщить об ошибке, если в качестве индекса массива используется число с плавающей точкой~\cite{aho2003}.

\img{1\textwidth}{1-4.pdf}{Семантический анализатор}

\subsection{Генерация кода}

В процессе трансляции исходной программы в целевой код компилятор может создавать одно или несколько промежуточных представлений различного вида. Синтаксические деревья являются видом промежуточного представления; обычно они используются в процессе синтаксического и семантического анализа~\cite{aho2003}.

После синтаксического и семантического анализа исходной программы многие компиляторы генерируют явное низкоуровневое или машинное промежуточное представление исходной программы, которое можно рассматривать как программу для абстрактной вычислительной машины. Такое промежуточное представление должно обладать двумя важными свойствами: оно должно легко генерироваться и легко транслироваться в целевой машинный язык~\cite{aho2003}.

Генератор кода получает в качестве входных данных промежуточное представление исходной программы и отображает его в целевой язык. Если целевой язык представляет собой машинный код, для каждой переменной, используемой программой, выбираются соответствующие регистры или ячейки памяти. Затем промежуточные команды транслируются в последовательности машинных команд, выполняющих те же действия. Ключевым моментом генерации кода является аккуратное распределение регистров для хранения переменных~\cite{aho2003}.

\subsection{Таблица символов}

Таблица символов представляет собой структуру данных, содержащую записи для каждого имени переменной, с полями для атрибутов имени. Структура данных должна быть разработана таким образом, чтобы позволять компилятору быстро находить запись для каждого имени, а также быстро сохранять данные в записи и получать их из нее~\cite{aho2003}.

Важная функция компилятора состоит в том, чтобы записывать имена переменных в исходной программе и накапливать информацию о разных атрибутах каждого имени. Эти атрибуты могут предоставлять информацию о выделенной памяти для данного имени, его типе, области видимости (где именно в программе может использоваться его значение) и, в случае имен процедур, такие сведения, как количество и типы их аргументов, метод передачи каждого аргумента (например, по значению или по ссылке), а также возвращаемый тип~\cite{aho2003}.



\subsection{Синтаксическое дерево}

Синтаксическое дерево~---~дерево, в котором каждый внутренний узел представляет операцию, а дочерние узлы~---~аргументы этой операции. Порядок операций в дереве согласуется с обычными правилами, например, умножение имеет более высокий приоритет, чем сложение, и должно быть выполнено до сложения~\cite{serebrykov2001}.

\img{0.6\textwidth}{parse_tree.png}{Пример синтаксического дерева}

\subsection{Генераторы лексических анализаторов}

Существует множество генераторов, наиболее популярные из них — Lex, Flex и ANTLR4.
Lex~---~стандартный инструмент для получения лексических анализа- торов в операционных системах Unix~\cite{lesk1975lex}. В результате обработки входного потока получается исходный файл на языке C. Lex-файл разделяется на три блока: блок определений, правил и кода на C.

Flex заменяет Lex в системах на базе пакетов GNU и имеет аналогичную функциональность~\cite{sampath2007test}.

ANTLR (ANother Tool for Language Recognition)~---~генератор лексических и синтаксических анализаторов, позволяет создавать анализаторы на таких языках, как: Java, Go, C++ и других~\cite{parr2004s}.
ANTLR генерирует классы нисходящего рекурсивного синтаксического анализатора, на основе правил, заданных грамматикой.

Он также позволяет строить и обходить деревья синтаксического ана- лиза с использованием паттернов посетитель или слушатель. Благодаря своей эффективности и простоте использования, ANTLR является одним из наиболее предпочтительных генераторов анализаторов при создании кода синтаксического анализатора. В текущей работе было решено использовать этот инструмент.

\subsection{Генераторы синтаксических анализаторов}

Для генерации синтаксических анализаторов применяются следующие инструменты:
\begin{itemize}
    \item Yacc/Bison: Yacc — стандартный генератор парсеров для Unix-систем, а Bison представляет его GNU-аналог~\cite{bhamidipaty1998very}.
    
    \item Coco/R: Комбинированный генератор лексических и синтаксических анализаторов~\cite{mossenbock1990coco}. Лексеры реализуют конечные автоматы, а парсеры используют метод рекурсивного спуска. Поддерживает языки C, Java и другие.
    
    \item ANTLR: Универсальный инструмент (ранее упомянутый) для создания анализаторов.
\end{itemize}

\subsubsection*{Методы разбора}
\begin{itemize}
    \item Yacc/Bison: Принимают контекстно-свободную грамматику и используют LALR-разбор (LR с предпросмотром). Канонические LR-анализаторы обладают несколько большей мощностью, но требуют значительных ресурсов памяти для таблиц, что ограничивает их практическое применение.
    
    \item ANTLR: Использует расширенный LL(*)-подход с поддержкой левой рекурсии.
    
    \item Coco/R: Основан на классическом LL(1)-разборе.
\end{itemize}

\subsubsection*{Сравнение LL и LR подходов}
LL(k)-анализаторы (k токенов предпросмотра)~\cite{aho2003}:
\begin{itemize}
    \item Строят левосторонний вывод
    \item Преимущества: Высокая скорость работы, простота реализации
    \item Недостатки: Задержки в обнаружении ошибок из-за откатов
\end{itemize}

LR-анализаторы:
\begin{itemize}
    \item Производят правый вывод
    \item Преимущества: Шире охват языков, раннее обнаружение ошибок
    \item Недостатки: Сложность реализации, ресурсоёмкие таблицы
\end{itemize}
LR-анализ эффективнее обнаруживает синтаксические ошибки при первом несоответствии грамматике, тогда как LL(k) может задерживать диагностику в случаях с общими префиксами альтернатив.

\subsection{LLVM}
Проект LLVM (Low Level Virtual Machine) представляет собой программную инфраструктуру для построения компиляторов и вспомогательных утилит \cite{sarda2015llvm}. Ключевые компоненты:

\begin{enumerate}
  \item LLVM IR: Платформонезависимое промежуточное представление (байткод). Генерируется для множества архитектур (ARM, x86/x86-64, GPU AMD/Nvidia и др.).
  
  \item Компиляция и исполнение: Преобразование IR в машинный код выполняется \texttt{clang}. Также доступен интерпретатор IR для непосредственного выполнения.
\end{enumerate}

\textbf{Особенности LLVM IR:}
\begin{itemize}
  \item Система типов: Поддерживает целые числа (arbitrary bitwidth), числа с плавающей точкой, массивы, структуры, функции, типизированные указатели.
  
  \item Инструкции: Преимущественно бинарные (два аргумента $\rightarrow$ один результат). Строгая статическая типизация: типы операндов и результата явно указаны и взаимосвязаны.
  
  \item Арифметика: Операнды должны совпадать по типу; операции перегружены для числовых типов и векторов.
  
  \item Преобразование типов: Требует явных инструкций приведения (включая int$\leftrightarrow$ptr и универсальную \texttt{bitcast}).
  
  \item Работа с памятью:
  \begin{itemize}
    \item \texttt{load} (чтение), \texttt{store} (запись) — доступ по типизированному указателю.
    \item \texttt{alloca} — выделение памяти на стеке (автоматическое освобождение при выходе из функции).
    \item \texttt{getelementptr} — \emph{вычисление адреса} (без доступа к памяти!) элементов структур/массивов с сохранением типизации, поддерживает произвольную вложенность и индексацию.
  \end{itemize}
\end{itemize}


\newpage

